#ifndef _TAMPLATEOBJECT_H
#define _TAMPLATEOBJECT_H

#include "BaseObject.h"
#include <stdio.h>
#include <time.h>

#define GUID_SIZE 24

struct _Object_Data_Info
{
    IObject*  m_pObject;       //指针对象
    int       m_nState;       //当前指针状态，0：不可用，1未使用，2正在使用

    _Object_Data_Info()
    {
        Init();
    }

    void Init()
    {
        m_pObject = NULL;
        m_nState  = 0;
    }
};

template <class T>
class COjectList
{
public:
    COjectList()
    {
        m_nType      = 0;
        m_nCount     = 0;
        m_objectList = NULL;
    };

    ~COjectList()
    {
        Close();
    };

    void Close()
    {
        delete[] m_objectList;
        m_objectList = NULL;
    }

    int Init(int nType, int nCount)
    {
        Close();

        m_nType    = nType;
        m_nCount   = nCount;

        m_objectList = new _Object_Data_Info[nCount];

        for (int i = 0; i < m_nCount; i++)
        {
            m_objectList[i].m_pObject = (IObject* )new T();
            m_objectList[i].m_nState  = 1;
        }

        m_nUsedCount = 0;
        m_nCurrIndex = 0;

        return 0;
    }

    //从内存池中获取一个空闲的对象
    T* Create(char* pObjectUID, int& nLen)
    {
        //从m_nCurrIndex往后找
        for (int i = m_nCurrIndex; i < m_nCount; i++)
        {
            if (m_objectList[i].m_nState == 1)
            {
                m_objectList[i].m_nState = 2; //标记位正在使用
                m_nCurrIndex = i;
                Create_Object_UID(pObjectUID, nLen, i);
                return (T*)m_objectList[i].m_pObject;
            }
        }

        //如果寻找到末尾还没找到，从头开始找
        for (int i = 0; i < m_nCurrIndex; i++)
        {
            if (m_objectList[i].m_nState == 1)
            {
                m_objectList[i].m_nState = 2; //标记位正在使用
                m_nCurrIndex = i;
                Create_Object_UID(pObjectUID, nLen, i);
                return (T*)m_objectList[i].m_pObject;
            }
        }

        //如果都没有找到
        printf("[Create]Object no can use object.\n");
        return NULL;
    }

    //归还一个正在使用的对象
    bool Delete(char* pObjectUID, int nLen, T* pt)
    {
        int nType = 0;
        int nPos  = 0;

        if (NULL == pt)
        {
            printf("[Delete]pObjectUID is NULL.\n");
            return false;
        }

        if (0 == Get_Object_UID_Info(pObjectUID, nLen, nType, nPos))
        {
            //回收对象
            m_objectList[nPos].m_nState = 1; //标记为未使用
            return true;
        }
        else
        {
            return false;
        }
    }

    //得到当前的缓冲池中的Count
    int Get_Count()
    {
        return m_nCount;
    }

private:
    //创建一个ObjectID
    int Create_Object_UID(char* pObjectUID, int& nLen, int nPos)
    {
        if (nLen < GUID_SIZE)
        {
            //给的GUID字符串内存不够
            printf("[Create_Object_UID]no enough GUID_SIZE(%d).\n", nLen);
            return -1;
        }

        //创建规则，时间+ClassID+数组下标
        time_t ttCurrentTime;
        time(&ttCurrentTime);
        struct tm tmTime;
#ifdef WIN32
        localtime_s(&tmTime, &ttCurrentTime);
#else
        localtime_r(&tmTime, &ttCurrentTime);
#endif
        char szTimeNow[50] = { '\0' };
        sprintf(szTimeNow, "%04d%02d%02d%02d%02d%02d",
                tmTime.tm_year + 1900,
                tmTime.tm_mon + 1,
                tmTime.tm_mday,
                tmTime.tm_hour,
                tmTime.tm_min,
                tmTime.tm_sec);

        sprintf(pObjectUID, "%s%04d%06d", szTimeNow, m_nType, nPos);
        nLen = GUID_SIZE;
        return 0;
    }

    //从一个ObjectUID中获得当前类型ID
    int Get_Object_UID_Info(char* pObjectUID, int nLen, int& nType, int& nPos)
    {
        if (GUID_SIZE != nLen)
        {
            printf("[Get_Object_UID_Info]error GUID_SIZE(%d).\n", nLen);
            return -1;
        }

        char szType[10] = { '\0' };
        char szPos[10]  = { '\0' };

        memcpy(szType, &pObjectUID[14], 4);
        memcpy(szPos, &pObjectUID[18], 6);

        nType = atoi(szType);
        nPos  = atoi(szPos);

        if (nType != m_nType || nPos < 0 || nPos >= m_nCount)
        {
            printf("[Get_Object_UID_Info]error nType=%d, nPos=%d.\n", nType, nPos);
            return -1;
        }

        return 0;
    }

private:
    int                m_nType;           //当前的类对象类型
    int                m_nCount;          //当前缓冲数组对象的个数
    int                m_nUsedCount;      //当前正在使用对象的个数
    int                m_nCurrIndex;      //当前指针，用于Create使用
    _Object_Data_Info* m_objectList;      //对象指针数组
};

#endif
